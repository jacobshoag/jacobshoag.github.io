<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Word Ladder Game ‚Äì English & Hebrew</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #f4f4f4;
    }
    .container {
      max-width: 500px;
      margin: 20px auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    input, button, select {
      font-size: 1rem;
      padding: 8px;
      margin: 5px;
    }
    #status { margin-top: 10px; font-weight: bold; }
    #wordChain {
      font-size: 1.1rem;
      margin-top: 10px;
      font-weight: bold;
      color: #007bff;
    }
    .button {
      display: inline-block;
      padding: 10px 15px;
      background-color: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      font-weight: bold;
      margin-top: 20px;
    }
    .button:hover { background-color: #0056b3; }

    /* ===== Desktop on-screen Hebrew keypad (palette) ===== */
    .kbd-grid {
      display: none;              /* shown only in Hebrew mode via JS */
      margin: 8px auto 0;
      max-width: 500px;
      gap: 6px;
      grid-template-columns: repeat(13, 1fr);
      direction: rtl;             /* flow keys right ‚Üí left */
    }
    .kbd-grid button {
      padding: 6px 0;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: #fafafa;
      cursor: pointer;
      font-size: 1rem;
    }
    .kbd-grid button:active { background: #eee; }
  </style>
</head>
<body>

  <h1>Word Ladder Game</h1>
  <div class="container">
    <p>Transform the start word into the target word, changing one letter at a time. Each step must be a real word!</p>

    <label for="languageSelect">Select Language:</label>
    <select id="languageSelect">
      <option value="english" selected>English</option>
      <option value="hebrew">Hebrew</option>
    </select>

    <label for="wordLength">Select Word Length:</label>
    <select id="wordLength">
      <option value="3">3-Letter Words</option>
      <option value="4">4-Letter Words</option>
    </select>
    <button onclick="restartGame()">Start Game</button>

    <p><strong>Start Word:</strong> <span id="startWord">-</span></p>
    <p><strong>Target Word:</strong> <span id="targetWord">-</span></p>

    <input type="text" id="wordInput" placeholder="Enter next word" />
    <button onclick="submitWord()">Submit</button>

    <!-- Desktop on-screen Hebrew keypad (palette) -->
    <div id="heKeypad" class="kbd-grid" aria-label="Hebrew keypad"></div>

    <p id="status"></p>

    <p><strong>Word Chain:</strong></p>
    <p id="wordChain">-</p>

    <p><strong>üß† Minimum Steps Required:</strong> <span id="minSteps">-</span></p>

    <a href="resources.html" class="button">Return to Resources</a>

    <h3>üîç How the Algorithm Works</h3>
    <p>
      The game uses a Breadth‚ÄëFirst Search (BFS) algorithm to find the shortest path between words. It builds a word graph where each valid word is connected to words that differ by just one letter, then explores transformations step by step. As you play, the game gives you puzzles with longer shortest possible chains.
    </p>
  </div>

  <script>
    /**
     * Word Ladder game supporting English and Hebrew dictionaries.
     * Preserves the feel of your original English file (2 ‚Üí 3 ‚Üí 4 ‚Ä¶ ramp)
     * and adds a right‚Äëto‚Äëleft on‚Äëscreen Hebrew keypad/palette.
     */

    // Dictionaries
    let englishWords = new Set();     // English (lowercase list)
    let hebrewWords  = new Set();     // Hebrew (raw forms as in file)
    let hebrewNormSet = new Set();    // Hebrew normalized forms for membership

    // Graph + game state
    let buckets = {};                 // pattern ‚Üí Set(words) for adjacency
    let currentWord = "";
    let targetWord  = "";
    let wordPath = [];
    let usedNorm = new Set();         // normalized forms used in chain
    let selectedWordLength = 3;
    let selectedLanguage   = 'english';
    let minChainLength = 2;           // ramp: 2 ‚Üí 3 ‚Üí 4 ‚Ä¶
    let shortestPathLen = 0;

    // DOM
    const inputEl  = document.getElementById('wordInput');
    const statusEl = document.getElementById('status');
    const chainEl  = document.getElementById('wordChain');
    const startEl  = document.getElementById('startWord');
    const targetEl = document.getElementById('targetWord');
    const minEl    = document.getElementById('minSteps');
    const lengthEl = document.getElementById('wordLength');
    const langEl   = document.getElementById('languageSelect');

    // Hebrew final-letter normalization
    const H_FINAL = { '◊ö':'◊õ', '◊ù':'◊û', '◊ü':'◊†', '◊£':'◊§', '◊•':'◊¶' };

    /** Strip niqqud and normalize final letters. */
    function normalizeHebrew(word) {
      const stripped = word.replace(/[\u05B0-\u05BC\u05BD-\u05C5\u05C7]/g, '');
      return stripped.split('').map(ch => H_FINAL[ch] || ch).join('');
    }

    /** Language-aware normalization for comparing / measuring distance. */
    function normalizeWord(word) {
      if (selectedLanguage === 'hebrew') return normalizeHebrew(word);
      return word.toLowerCase();
    }

    /** Enable/disable controls. */
    function disableInputs(disabled) {
      inputEl.disabled = disabled;
      document.querySelector("button[onclick='submitWord()']").disabled = disabled;
      document.querySelector("button[onclick='restartGame()']").disabled = disabled;
      lengthEl.disabled = disabled;
      langEl.disabled   = disabled;
    }

    /** Load both dictionaries and precompute Hebrew normalized membership set. */
    async function loadDictionaries() {
      disableInputs(true);
      try {
        const [engText, hebText] = await Promise.all([
          fetch('assets/other/corncob_lowercase.txt').then(r => r.text()),
          fetch('assets/other/hebrew_words.txt').then(r => r.text())
        ]);
        englishWords = new Set(
          engText.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(Boolean)
        );
        hebrewWords = new Set(
          hebText.split(/\r?\n/).map(w => w.trim()).filter(Boolean)
        );
        hebrewNormSet = new Set(Array.from(hebrewWords, w => normalizeHebrew(w)));
        restartGame();
      } catch (error) {
        statusEl.innerText = "Error loading word lists.";
        console.error('Failed to load dictionaries:', error);
      } finally {
        disableInputs(false);
      }
    }

    /** Build pattern buckets (using normalized keys) in O(N¬∑L). */
    function buildBuckets(setWords, L) {
      buckets = {};
      for (const w of setWords) {
        const norm = normalizeWord(w);
        for (let i = 0; i < L; i++) {
          const key = norm.slice(0, i) + '*' + norm.slice(i + 1);
          if (!buckets[key]) buckets[key] = new Set();
          buckets[key].add(w);
        }
      }
    }

    /** Yield neighbors differing by exactly one normalized letter. */
    function* neighbors(word) {
      const norm = normalizeWord(word);
      for (let i = 0; i < norm.length; i++) {
        const key = norm.slice(0, i) + '*' + norm.slice(i + 1);
        const group = buckets[key];
        if (!group) continue;
        for (const other of group) {
          if (other !== word) yield other;
        }
      }
    }

    /** Single-source BFS: distances + parent pointers. */
    function bfsFrom(start) {
      const dist = new Map([[start, 0]]);
      const parent = new Map();
      const q = [start];
      while (q.length) {
        const w = q.shift();
        const d = dist.get(w);
        for (const nb of neighbors(w)) {
          if (dist.has(nb)) continue;
          dist.set(nb, d + 1);
          parent.set(nb, w);
          q.push(nb);
        }
      }
      return { dist, parent };
    }

    /** Reconstruct path using a parent map. */
    function backtrack(parent, start, goal) {
      const path = [goal];
      let cur = goal;
      while (cur !== start) {
        const p = parent.get(cur);
        if (!p) return null;
        cur = p;
        path.push(cur);
      }
      path.reverse();
      return path;
    }

    /**
     * Prefer puzzles with shortest path == current difficulty; if none exist
     * after several tries, fallback to the nearest longer path (not the furthest).
     */
    function choosePair(validWords, exactLen) {
      const words = Array.from(validWords);
      if (words.length < 2) return null;

      const TRIES = Math.min(60, words.length);
      let bestOver = null; // {start, goal, pathLen} minimal > exactLen

      for (let t = 0; t < TRIES; t++) {
        const start = words[(Math.random() * words.length) | 0];
        const { dist, parent } = bfsFrom(start);

        const exact = [];
        const over  = [];
        for (const [w, d] of dist.entries()) {
          if (w === start) continue;
          if (d === exactLen) exact.push([w, d]);
          else if (d > exactLen) over.push([w, d]);
        }

        if (exact.length) {
          const [goal, d] = exact[(Math.random() * exact.length) | 0];
          const path = backtrack(parent, start, goal);
          if (path) return { start, goal, pathLen: d };
        }

        if (over.length) {
          over.sort((a, b) => a[1] - b[1]); // nearest longer
          const [goal, d] = over[0];
          const path = backtrack(parent, start, goal);
          if (path && (!bestOver || d < bestOver.pathLen)) {
            bestOver = { start, goal, pathLen: d };
          }
        }
      }
      return bestOver;
    }

    /** Start a new round with current settings. */
    function startNewGame() {
      selectedWordLength = parseInt(lengthEl.value, 10);
      selectedLanguage   = langEl.value;

      // Update input hints & keypad for the current language
      setInputLanguageUI(selectedLanguage);

      // Filter words by normalized length, letters only
      const source = (selectedLanguage === 'hebrew') ? hebrewWords : englishWords;
      const validWords = new Set();
      for (const w of source) {
        const norm = (selectedLanguage === 'hebrew') ? normalizeHebrew(w) : w;
        if (norm.length === selectedWordLength && /^[\p{L}]+$/u.test(norm)) {
          validWords.add(w);
        }
      }
      if (validWords.size < 2) {
        statusEl.innerText = "Not enough words of this length in the selected language.";
        return;
      }

      buildBuckets(validWords, selectedWordLength);
      const pick = choosePair(validWords, minChainLength);
      if (!pick) {
        statusEl.innerText = "No solvable pair found. Try another length or language.";
        return;
      }

      currentWord     = pick.start;
      targetWord      = pick.goal;
      shortestPathLen = pick.pathLen;

      wordPath = [currentWord];
      usedNorm = new Set([normalizeWord(currentWord)]);

      startEl.innerText  = currentWord;
      targetEl.innerText = targetWord;
      chainEl.innerText  = wordPath.join(" ‚Üí ");
      inputEl.value = "";
      statusEl.innerText = "Game started! Enter words to reach the target.";
      minEl.innerText    = shortestPathLen;

      // Increase difficulty for next round
      minChainLength++;
    }

    /** Validate input and progress the game. */
    function submitWord() {
      const raw = inputEl.value.trim();
      if (!raw) return;

      // Dictionary membership (language-aware)
      let typed = raw;
      let inDict = false;
      if (selectedLanguage === 'english') {
        typed = raw.toLowerCase();
        inDict = englishWords.has(typed);
      } else {
        const norm = normalizeHebrew(raw);
        inDict = hebrewNormSet.has(norm);
      }
      if (!inDict) {
        statusEl.innerText = "That word is not in the allowed dictionary.";
        return;
      }

      // Length check (normalized)
      const normTyped = normalizeWord(typed);
      if (normTyped.length !== selectedWordLength) {
        statusEl.innerText = "Word must be exactly " + selectedWordLength + " letters.";
        return;
      }

      // One-letter difference check (normalized)
      const a = normalizeWord(currentWord);
      const b = normTyped;
      let diff = 0;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          diff++;
          if (diff > 1) break;
        }
      }
      if (diff !== 1) {
        statusEl.innerText = "Word must differ by exactly one letter!";
        return;
      }

      // Prevent reuse (normalized)
      if (usedNorm.has(b)) {
        statusEl.innerText = "You already used that word!";
        return;
      }

      // Commit move
      wordPath.push(typed);
      usedNorm.add(b);
      currentWord = typed;
      inputEl.value = "";
      chainEl.innerText = wordPath.join(" ‚Üí ");

      // Win check (normalized equality)
      if (normalizeWord(currentWord) === normalizeWord(targetWord)) {
        statusEl.innerText = "üéâ You won! Next puzzle loading...";
        disableInputs(true);
        setTimeout(() => {
          disableInputs(false);
          startNewGame();
        }, 1200);
      } else {
        statusEl.innerText = "Good! Keep going.";
      }
    }

    /** Reset difficulty and start fresh. */
    function restartGame() {
      minChainLength = 2;
      startNewGame();
    }

    /* ===== Hebrew desktop keypad (palette) + input language hints ===== */

    const HEBREW_KEYS = [
      '◊ê','◊ë','◊í','◊ì','◊î','◊ï','◊ñ','◊ó','◊ò','◊ô','◊õ','◊ö','◊ú',
      '◊û','◊ù','◊†','◊ü','◊°','◊¢','◊§','◊£','◊¶','◊•','◊ß','◊®','◊©','◊™','◊≥','÷æ'
    ];

    function buildHebrewKeypad() {
      const pad = document.getElementById('heKeypad');
      pad.innerHTML = '';
      for (const ch of HEBREW_KEYS) {
        const b = document.createElement('button');
        b.type = 'button';
        b.textContent = ch;
        b.addEventListener('click', () => insertAtCursor(inputEl, ch));
        pad.appendChild(b);
      }
    }

    function insertAtCursor(el, text) {
      const start = el.selectionStart ?? el.value.length;
      const end   = el.selectionEnd   ?? el.value.length;
      el.value = el.value.slice(0, start) + text + el.value.slice(end);
      const pos = start + text.length;
      el.setSelectionRange(pos, pos);
      el.focus();
    }

    function setInputLanguageUI(lang) {
      const pad = document.getElementById('heKeypad');

      // Strong hints for keyboards and accessibility:
      inputEl.setAttribute('lang', lang === 'hebrew' ? 'he' : 'en');
      inputEl.dir = (lang === 'hebrew') ? 'rtl' : 'ltr';
      inputEl.autocapitalize = 'off';
      inputEl.autocomplete   = 'off';
      inputEl.spellcheck     = (lang === 'hebrew');
      inputEl.setAttribute('enterkeyhint', 'go');

      // Show/hide in‚Äëpage keypad (palette), and ensure it flows RTL in Hebrew
      if (lang === 'hebrew') {
        pad.dir = 'rtl';
        pad.style.display = 'grid';
        buildHebrewKeypad();
      } else {
        pad.style.display = 'none';
      }
    }

    // Boot
    loadDictionaries();

    // Enter to submit + react to language changes
    window.addEventListener("DOMContentLoaded", () => {
      inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          submitWord();
        }
      });
      langEl.addEventListener('change', () => {
        setInputLanguageUI(langEl.value);
        restartGame();
      });
    });
  </script>
</body>
</html>

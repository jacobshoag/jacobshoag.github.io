<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Word Ladder Game ‚Äì English & Hebrew</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #f4f4f4;
    }
    .container {
      max-width: 500px;
      margin: 20px auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    input, button, select {
      font-size: 1rem;
      padding: 8px;
      margin: 5px;
    }
    #status {
      margin-top: 10px;
      font-weight: bold;
    }
    #wordChain {
      font-size: 1.1rem;
      margin-top: 10px;
      font-weight: bold;
      color: #007bff;
    }
    .button {
      display: inline-block;
      padding: 10px 15px;
      background-color: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      font-weight: bold;
      margin-top: 20px;
    }
    .button:hover { background-color: #0056b3; }
  </style>
</head>
<body>

  <h1>Word Ladder Game</h1>
  <div class="container">
    <p>Transform the start word into the target word, changing one letter at a time. Each step must be a real word!</p>

    <div>
      <label for="languageSelect">Select Language:</label>
      <select id="languageSelect">
        <option value="english" selected>English</option>
        <option value="hebrew">Hebrew</option>
      </select>

      <label for="wordLength">Select Word Length:</label>
      <select id="wordLength">
        <option value="3">3-Letter Words</option>
        <option value="4">4-Letter Words</option>
      </select>

      <button onclick="restartGame()">Start Game</button>
    </div>

    <p><strong>Start Word:</strong> <span id="startWord">-</span></p>
    <p><strong>Target Word:</strong> <span id="targetWord">-</span></p>

    <input type="text" id="wordInput" placeholder="Enter next word" />
    <button onclick="submitWord()">Submit</button>
    <p id="status"></p>

    <p><strong>Word Chain:</strong></p>
    <p id="wordChain">-</p>

    <p><strong>üß† Minimum Steps Required:</strong> <span id="minSteps">-</span></p>

    <a href="resources.html" class="button">Return to Resources</a>

    <h3>üîç How the Algorithm Works</h3>
    <p>
      The game uses a Breadth‚ÄëFirst Search (BFS) algorithm to find the shortest path between words. It builds a word graph where each valid word is connected to words that differ by just one letter, then explores transformations step by step. As you play, the game gives you puzzles with longer shortest possible chains.
    </p>
  </div>

  <script>
    /** ========= Word Ladder (English + Hebrew) ‚Äì FIXED ========= */

    // Dictionaries (English in lowercase; Hebrew raw as in file)
    let englishWords = new Set();
    let hebrewWords  = new Set();
    let hebrewNormSet = new Set(); // normalized Hebrew forms for membership

    // Adjacency helpers and game state
    let buckets = {};                 // pattern -> Set(words) for neighbors
    let currentWord = "";
    let targetWord  = "";
    let wordPath = [];
    let usedNorm = new Set();         // normalized forms used in chain
    let selectedWordLength = 3;
    let selectedLanguage   = "english";
    let minChainLength = 2;           // difficulty ramp: 2, 3, 4, ...
    let shortestPathLen = 0;

    // DOM
    const inputEl  = document.getElementById("wordInput");
    const statusEl = document.getElementById("status");
    const chainEl  = document.getElementById("wordChain");
    const startEl  = document.getElementById("startWord");
    const targetEl = document.getElementById("targetWord");
    const minEl    = document.getElementById("minSteps");
    const lengthEl = document.getElementById("wordLength");
    const langEl   = document.getElementById("languageSelect");

    // Final-form mapping for Hebrew (normalize end letters)
    const H_FINAL = { "◊ö":"◊õ", "◊ù":"◊û", "◊ü":"◊†", "◊£":"◊§", "◊•":"◊¶" };

    /** Strip niqqud and convert final letters to standard forms. */
    function normalizeHebrew(word) {
      const noNiqqud = word.replace(/[\u05B0-\u05BC\u05BD-\u05C5\u05C7]/g, "");
      return noNiqqud.split("").map(ch => H_FINAL[ch] || ch).join("");
    }

    /** Language-aware normalization for comparing / measuring distance. */
    function normalizeWord(word) {
      if (selectedLanguage === "hebrew") return normalizeHebrew(word);
      return word.toLowerCase();
    }

    function disableInputs(disabled) {
      inputEl.disabled = disabled;
      document.querySelector("button[onclick='submitWord()']").disabled = disabled;
      document.querySelector("button[onclick='restartGame()']").disabled = disabled;
      lengthEl.disabled = disabled;
      langEl.disabled   = disabled;
    }

    /** Load both dictionaries. */
    async function loadDictionaries() {
      disableInputs(true);
      try {
        const [engText, hebText] = await Promise.all([
          fetch("assets/other/corncob_lowercase.txt").then(r => r.text()),
          fetch("assets/other/hebrew_words.txt").then(r => r.text())
        ]);
        englishWords = new Set(
          engText.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(Boolean)
        );
        hebrewWords = new Set(
          hebText.split(/\r?\n/).map(w => w.trim()).filter(Boolean)
        );
        hebrewNormSet = new Set(Array.from(hebrewWords, w => normalizeHebrew(w)));
        restartGame();
      } catch (e) {
        statusEl.innerText = "Error loading word lists.";
        console.error(e);
      } finally {
        disableInputs(false);
      }
    }

    /** Build pattern buckets (normalized) in O(N¬∑L). */
    function buildBuckets(setWords, L) {
      buckets = {};
      for (const w of setWords) {
        const norm = normalizeWord(w);
        for (let i = 0; i < L; i++) {
          const key = norm.slice(0, i) + "*" + norm.slice(i + 1);
          if (!buckets[key]) buckets[key] = new Set();
          buckets[key].add(w);
        }
      }
    }

    /** Generate neighbors that differ by exactly one normalized letter. */
    function* neighbors(word) {
      const norm = normalizeWord(word);
      for (let i = 0; i < norm.length; i++) {
        const key = norm.slice(0, i) + "*" + norm.slice(i + 1);
        const group = buckets[key];
        if (!group) continue;
        for (const other of group) {
          if (other !== word) yield other;
        }
      }
    }

    /** BFS from a start word: distances (steps) and parent pointers. */
    function bfsFrom(start) {
      const dist = new Map([[start, 0]]);
      const parent = new Map();
      const q = [start];
      while (q.length) {
        const w = q.shift();
        const d = dist.get(w);
        for (const nb of neighbors(w)) {
          if (dist.has(nb)) continue;
          dist.set(nb, d + 1);
          parent.set(nb, w);
          q.push(nb);
        }
      }
      return { dist, parent };
    }

    /** Reconstruct path using a parent map. */
    function backtrack(parent, start, goal) {
      const path = [goal];
      let cur = goal;
      while (cur !== start) {
        const p = parent.get(cur);
        if (!p) return null;
        cur = p;
        path.push(cur);
      }
      path.reverse();
      return path;
    }

    /**
     * Choose a pair whose shortest path equals current difficulty if possible.
     * Fallback: the nearest longer path (not the furthest).
     */
    function choosePair(validWords, exactLen) {
      const words = Array.from(validWords);
      if (words.length < 2) return null;

      const TRIES = Math.min(60, words.length);
      let bestOver = null; // {start, goal, pathLen} with minimal pathLen > exactLen

      for (let t = 0; t < TRIES; t++) {
        const start = words[(Math.random() * words.length) | 0];
        const { dist, parent } = bfsFrom(start);

        const exact = [];
        const over  = [];
        for (const [w, d] of dist.entries()) {
          if (w === start) continue;
          if (d === exactLen) exact.push([w, d]);
          else if (d > exactLen) over.push([w, d]);
        }

        if (exact.length) {
          const [goal, d] = exact[(Math.random() * exact.length) | 0];
          const path = backtrack(parent, start, goal);
          if (path) return { start, goal, pathLen: d };
        }

        if (over.length) {
          over.sort((a, b) => a[1] - b[1]); // nearest longer
          const [goal, d] = over[0];
          const path = backtrack(parent, start, goal);
          if (path && (!bestOver || d < bestOver.pathLen)) {
            bestOver = { start, goal, pathLen: d };
          }
        }
      }
      return bestOver;
    }

    /** Start a new game with current language and length. */
    function startNewGame() {
      selectedWordLength = parseInt(lengthEl.value, 10);
      selectedLanguage   = langEl.value;

      // Flip input direction for Hebrew
      inputEl.dir = (selectedLanguage === "hebrew") ? "rtl" : "ltr";

      // Filter words by normalized length
      const source = (selectedLanguage === "hebrew") ? hebrewWords : englishWords;
      const validWords = new Set();
      for (const w of source) {
        const norm = (selectedLanguage === "hebrew") ? normalizeHebrew(w) : w;
        if (norm.length === selectedWordLength) validWords.add(w);
      }

      if (validWords.size < 2) {
        statusEl.innerText = "Not enough words of this length in the selected language.";
        return;
      }

      buildBuckets(validWords, selectedWordLength);

      const pick = choosePair(validWords, minChainLength);
      if (!pick) {
        statusEl.innerText = "No solvable pair found. Try a different length or language.";
        return;
      }

      currentWord     = pick.start;
      targetWord      = pick.goal;
      shortestPathLen = pick.pathLen;

      wordPath = [currentWord];
      usedNorm = new Set([normalizeWord(currentWord)]);
      startEl.innerText  = currentWord;
      targetEl.innerText = targetWord;
      chainEl.innerText  = wordPath.join(" ‚Üí ");
      inputEl.value = "";
      statusEl.innerText = "Game started! Enter words to reach the target.";
      minEl.innerText    = shortestPathLen;

      // Increase difficulty for next round
      minChainLength++;
    }

    /** Validate input and progress game. */
    function submitWord() {
      let typed = inputEl.value.trim();
      if (!typed) return;

      // Membership check (language-aware)
      let inDict = false;
      if (selectedLanguage === "english") {
        typed = typed.toLowerCase();
        inDict = englishWords.has(typed);
      } else {
        inDict = hebrewNormSet.has(normalizeHebrew(typed));
      }
      if (!inDict) {
        statusEl.innerText = "That word is not in the allowed dictionary.";
        return;
      }

      // Length check on normalized forms
      const normTyped = normalizeWord(typed);
      if (normTyped.length !== selectedWordLength) {
        statusEl.innerText = "Word must be exactly " + selectedWordLength + " letters.";
        return;
      }

      // One-letter difference check (normalized)
      const a = normalizeWord(currentWord);
      const b = normTyped;
      let diff = 0;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          diff++;
          if (diff > 1) break;
        }
      }
      if (diff !== 1) {
        statusEl.innerText = "Word must differ by exactly one letter!";
        return;
      }

      // Prevent reuse (by normalized form)
      if (usedNorm.has(b)) {
        statusEl.innerText = "You already used that word!";
        return;
      }

      // Commit move
      wordPath.push(typed);
      usedNorm.add(b);
      currentWord = typed;
      inputEl.value = "";
      chainEl.innerText = wordPath.join(" ‚Üí ");

      // Win check (normalized equality)
      if (normalizeWord(currentWord) === normalizeWord(targetWord)) {
        statusEl.innerText = "üéâ You won! Next puzzle loading...";
        disableInputs(true);
        setTimeout(() => {
          disableInputs(false);
          startNewGame();
        }, 1200);
      } else {
        statusEl.innerText = "Good! Keep going.";
      }
    }

    /** Manual reset to difficulty 2 and start fresh. */
    function restartGame() {
      minChainLength = 2;
      startNewGame();
    }

    // Boot
    loadDictionaries();

    // Enter key to submit + restart when language changes
    window.addEventListener("DOMContentLoaded", () => {
      document.getElementById("wordInput").addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          submitWord();
        }
      });
      langEl.addEventListener("change", () => restartGame());
    });
  </script>
</body>
</html>
